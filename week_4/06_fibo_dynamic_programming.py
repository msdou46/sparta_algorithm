print('---------------------- 4-8 Dynamic Programming(동적 계획법) - 피보나치 수열, 동적 계획법 ----------------------')


input = 100

# memo 라는 변수에 Fibo(1)과 Fibo(2) 값을 저장해놨습니다!
memo = {
    1: 1,
    2: 1
}

def fibo_dynamic_programming(n, fibo_memo):

    if n in fibo_memo:      # 가장 먼저, 입력한 '피보나치 수열 n번째 숫자' 의 값이 이미 저장되어 있다면 그냥 꺼내서 사용.
        return fibo_memo[n]
    nth_fibo = fibo_dynamic_programming(n - 1, fibo_memo) + fibo_dynamic_programming(n - 2, fibo_memo)
                # 만약 fibo_memo 에 n 이 없다면, 함수를 재귀 호출해서 n번째 값을 구하려고 시도해.
                # 각각 n-1 과 n-2 의 숫자를 매개변수로 주며, 해당 값이 fibo_memo 에 없을 경우 다시 또 재귀 호출하겠지.
                # n-1 과 n-2 를 매개변수로 받은 함수는, 해당 값이 없을 경우 다시 n-1, n-2 를 해서 함수를 재귀 호출하겠지. 그걸 계속 반복.
                # 그렇게 나무가 가지를 여러 갈래로 뻣어 나가듯, 재귀 함수의 갈래가 완성 돼. 그렇게 수십 수백의 함수가 완성된 거야.
                # 여기서 부터가 중요해.
                # 가장 처음에 기본값으로 fibo_memo 에는 1 과 2에 대한 값을 이미 저장해 뒀어.
                # 따라서 재귀 함수의 가지가 끝까지 뻣으면, 결국에는 if문에 걸려서 재귀를 탈출해.
                # 그리고 더 이상 재귀를 하지 않게 된 순간 부터, 뻣어 나갔던 가지들은 마치 시간이 되돌아 가듯 다시 나무의 기둥을 향해 하나로 합쳐지기 시작.
                # 여기서 하나로 합쳐지기 시작한 다는 것은,
                    # nth_fibo = fibo_dynamic_programming(n - 1, fibo_memo) + fibo_dynamic_programming(n - 2, fibo_memo)
                # 여기에서 걸려서 계속 재귀를 뻣어 나가던 함수가, 맨 끝의 함수부터, 즉 가지 끝 부분부터 리턴을 하기 시작했다는 뜻.
                # n이 2, 1 까지 내려갔을 때, 더 이상 재귀를 호출하지 않고 2와 1을 if문에서 리턴 받아서 그 값으로 nth_fibo 를 구했을거야.
                # n = 3은 n=1, n=2 의 값을 if문에서 리턴받고, fibo_memo[3] = 3 이라는 값을 저장했을 거야. 여기서부터 재귀의 스택이 리턴되기 시작.
                # n=3, n=4, n=5 이렇게 다시 스택을 꺼내며 리턴을 거슬러 올라가면서, 해당 값을 fibo_memo[n] = nth_fibo 에 저장해.
                # 그렇다면, 재귀가 한 단계 위로 거슬러 올라갔을 때 nth_fibo = fibo(n-1), fibo(n-2)를 호출하면,
                # 이미 나뭇 가지 끝 쪽 부터 해서 fibo_memo[n] = nth_fibo 로 값이 저장되어 올라왔기에 바로 if문에서 return 을 받아서 값을 사용.
                # 즉, 스택이 거슬러 올라오는 과정에서 이전 단계에 이미 값이 저장되어 있는 상태이기 때문에 그 값을 참조하기만 하면 된다는 거야.
                    # 여기서 알 수 있는 건, 함수의 도중에서 재귀 호출이 일어나더라도, 나뭇 가지가 다 완성된  시점에서 리턴이 시작되면
                    # 재귀가 걸린 부분부터 코드가 시작되는 것이 아니라, 함수 전체가 컴파일링 된다는 것.
                    # 즉, 재귀가 펼쳐지는 과정에서는 함수의 코드만 문서화 되는 것이고, 실재로 컴파일링은 재귀가 끝난 시점부터 한 줄 한 줄 읽어 간다는 것.
    fibo_memo[n] = nth_fibo
    return nth_fibo

print(fibo_dynamic_programming(input, memo))